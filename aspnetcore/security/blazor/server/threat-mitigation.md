---
title: Руководство по предотвращению угроз для ASP.NET Core Blazor Server
author: guardrex
description: Узнайте, как устранить угрозы безопасности для Blazor серверных приложений.
monikerRange: '>= aspnetcore-3.1'
ms.author: riande
ms.custom: mvc
ms.date: 05/05/2020
no-loc:
- Blazor
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: security/blazor/server/threat-mitigation
ms.openlocfilehash: 06f9cc2d70367ea90a519ddd508a156e88adcb61
ms.sourcegitcommit: 6a71b560d897e13ad5b61d07afe4fcb57f8ef6dc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/09/2020
ms.locfileid: "83864635"
---
# <a name="threat-mitigation-guidance-for-aspnet-core-blazor-server"></a>Руководство по предотвращению угроз для ASP.NET Core Blazor Server

Автор: [Javier Calvarro Nelson](https://github.com/javiercn) (Хавьер Кальварро Нельсон)

BlazorСерверные приложения принимают модель обработки данных с *отслеживанием состояния* , где сервер и клиент поддерживают долгосрочную связь. Постоянное состояние поддерживается [каналом](xref:blazor/state-management), который может охватывать соединения, которые также потенциально долго исключаются.

Когда пользователь посещает Blazor сайт сервера, сервер создает канал в памяти сервера. Канал указывает браузеру, какое содержимое подготавливается к просмотру, и реагирует на события, например, когда пользователь выбирает кнопку в пользовательском интерфейсе. Для выполнения этих действий цепь вызывает функции JavaScript в браузере пользователя и методах .NET на сервере. Это двустороннее взаимодействие на основе JavaScript называется взаимодействием [JavaScript (JS Interop)](xref:blazor/call-javascript-from-dotnet).

Поскольку взаимодействие с JS происходит через Интернет, а клиент использует удаленный браузер, Blazor серверные приложения совместно используют большинство проблем безопасности веб-приложений. В этом разделе описываются распространенные угрозы для Blazor серверных приложений и предоставляются рекомендации по предотвращению угроз, направленные на приложения с выходом в Интернет.

В ограниченных средах, например в корпоративных сетях или интрасетях, некоторые рекомендации по устранению рисков:

* Не применяется в ограниченной среде.
* Не стоит тратить затраты на реализацию, так как в ограниченной среде существует угроза безопасности.

## <a name="blazor-and-shared-state"></a>Blazor и общее состояние

[!INCLUDE[](~/includes/blazor-security/blazor-shared-state.md)]

## <a name="resource-exhaustion"></a>Нехватка ресурсов

Нехватка ресурсов может произойти, когда клиент взаимодействует с сервером и заставляет сервер потреблять чрезмерные ресурсы. Чрезмерное потребление ресурсов в основном влияет на:

* [ЦП](#cpu)
* [Память](#memory)
* [Клиентские подключения](#client-connections)

Атаки типа "отказ в обслуживании" (DoS) обычно ищут исчерпание ресурсов приложения или сервера. Однако нехватка ресурсов не обязательно является результатом атаки на систему. Например, ограниченные ресурсы могут быть исчерпаны из-за высокой потребности пользователей. DoS рассматривается в разделе [атаки типа "отказ в обслуживании" (DOS)](#denial-of-service-dos-attacks) .

Ресурсы, внешние по отношению к Blazor платформе, такие как базы данных и дескрипторы файлов (используемые для чтения и записи файлов), могут также испытывать нехватку ресурсов. Для получения дополнительной информации см. <xref:performance/performance-best-practices>.

### <a name="cpu"></a>ЦП

Нехватка ресурсов ЦП может возникать, когда один или несколько клиентов вынуждены заставить сервер выполнять интенсивную работу ЦП.

Например, рассмотрим Blazor серверное приложение, которое вычисляет *фибоннакЦи число*. Номер ФибоннакЦи создается из последовательности ФибоннакЦи, где каждое число в последовательности является суммой двух предыдущих чисел. Объем работы, необходимый для достижения ответа, зависит от длины последовательности и размера начального значения. Если приложение не помещает ограничения на клиентский запрос, вычисления с интенсивным использованием ЦП могут повлиять на время ЦП и уменьшить производительность других задач. Чрезмерное потребление ресурсов является проблемой безопасности, влияющей на доступность.

Нехватка ресурсов ЦП очень важна для всех общедоступных приложений. В обычных веб-приложениях время ожидания запросов и соединений является защитой, но Blazor серверные приложения не обеспечивают одинаковые меры безопасности. BlazorСерверные приложения должны включать соответствующие проверки и ограничения перед выполнением потенциально требовательных к ЦП операций.

### <a name="memory"></a>Память

Нехватка памяти может произойти, когда один или несколько клиентов вынуждены принудительно использовать большой объем памяти.

Например, рассмотрим приложение на Blazor стороне сервера с компонентом, который принимает и отображает список элементов. Если Blazor приложение не помещает ограничения на число разрешенных элементов или число элементов, отображаемых обратно клиенту, обработка и отрисовка с интенсивным использованием памяти может полагаться на то, что производительность сервера снижается. Сервер может аварийно завершить работу или замедляться до момента сбоя.

Рассмотрим следующий сценарий для обслуживания и отображения списка элементов, относящихся к потенциальному сценарию нехватки памяти на сервере:

* Элементы в `List<MyItem>` свойстве или поле используют память сервера. Если приложение разрешает неограниченный рост списка элементов, существует риск нехватки памяти на сервере. При нехватке памяти текущий сеанс завершается (со сбоем) и все параллельные сеансы в этом экземпляре сервера получают исключение нехватки памяти. Чтобы предотвратить возникновение этого сценария, приложение должно использовать структуру данных, которая накладывает ограничение на число элементов для параллельных пользователей.
* Если схема подкачки не используется для отрисовки, сервер использует дополнительную память для объектов, которые не видны в пользовательском интерфейсе. Без ограничения на количество элементов требования к памяти могут привести к исчерпанию доступной памяти сервера. Чтобы предотвратить такой сценарий, используйте один из следующих подходов:
  * Используйте списки с разбивкой на страницы при подготовке к просмотру.
  * Отображать только первые 100 – 1 000 элементов и требовать от пользователя ввести условия поиска для поиска элементов за пределами отображаемых элементов.
  * Для более расширенного сценария подготовки к просмотру реализуйте списки или сетки, поддерживающие *виртуализацию*. С помощью виртуализации в списках отображаются только подмножество элементов, видимых пользователю. Когда пользователь взаимодействует с полосой прокрутки в пользовательском интерфейсе, компонент отображает только те элементы, которые требуются для отображения. Элементы, которые в данный момент не требуются для вывода, могут храниться во вторичном хранилище, что является идеальным подходом. Неотображаемые элементы также могут храниться в памяти, что является менее идеальным.

BlazorСерверные приложения предлагают аналогичную модель программирования для других платформ пользовательского интерфейса для приложений с отслеживанием состояния, таких как WPF, Windows Forms или Blazor сборки. Основное отличие состоит в том, что в некоторых платформах пользовательского интерфейса объем памяти, потребляемой приложением, принадлежит клиенту и влияет только на этот клиент. Например, Blazor приложение сборки на клиенте выполняется полностью и использует только ресурсы памяти клиента. В Blazor сценарии сервера память, потребляемая приложением, принадлежит серверу и является общей для клиентов на экземпляре сервера.

Требования к памяти на стороне сервера учитываются для всех Blazor серверных приложений. Однако большинство веб-приложений не имеют состояния, и память, используемая при обработке запроса, освобождается при возврате ответа. В качестве общей рекомендации не разрешите клиентам выделять неограниченный объем памяти, как в любом другом серверном приложении, сохраняющем клиентские подключения. Память, потребляемая Blazor серверным приложением, сохраняется дольше одного запроса.

> [!NOTE]
> Во время разработки можно использовать профилировщик или трассировку, отслеживаемую для оценки требований к памяти клиентов. Профилировщик или трассировка не захватывает память, выделенную для конкретного клиента. Чтобы записать использование памяти конкретным клиентом во время разработки, запишите дамп и изучите потребность в памяти для всех объектов, имеющих корень в цепи пользователя.

### <a name="client-connections"></a>Клиентские подключения

Нехватка подключений может возникать, когда один или несколько клиентов открывают слишком много одновременных подключений к серверу, предотвращая установку новых подключений другими клиентами.

Blazorклиенты устанавливают одно подключение к сеансу и сохраняют соединение в открытом окне, пока открыто окно браузера. Требования к серверу для обслуживания всех подключений не относятся к Blazor приложениям. Учитывая постоянную природу подключений и характерность Blazor серверных приложений, нехватка подключений — это более высокий риск доступности приложения.

По умолчанию количество подключений на одного пользователя для Blazor серверного приложения не ограничено. Если для приложения требуется ограничение числа подключений, воспользуйтесь одним или несколькими из следующих подходов.

* Требовать проверку подлинности, которая естественным образом ограничивает возможность неавторизованных пользователей подключаться к приложению. Чтобы этот сценарий действовал, пользователи должны быть предотвращены от подготовки новых пользователей.
* Ограничьте число подключений на пользователя. Ограничение подключений можно выполнить с помощью следующих подходов. Примите во внимание, чтобы предоставить законным пользователям доступ к приложению (например, если установлено ограничение на число подключений на основе IP-адреса клиента).
  * На уровне приложения:
    * Расширяемость маршрутизации конечных точек.
    * Требовать проверку подлинности для подключения к приложению и наблюдения за активными сеансами на пользователя.
    * Отклоните новые сеансы при достижении предела.
    * Прокси-подключения WebSocket к приложению с помощью прокси-сервера, например [ SignalR службы Azure](/azure/azure-signalr/signalr-overview) , которая мультиплексует подключения от клиентов к приложению. Это предоставляет приложению более высокую емкость подключения, чем может установить один клиент, что предотвращает исчерпание подключений клиента к серверу.
  * На уровне сервера: Используйте прокси-сервер или шлюз перед приложением. Например, [Передняя дверца Azure](/azure/frontdoor/front-door-overview) позволяет определять и отслеживать глобальную маршрутизацию веб-трафика в приложение, а также управлять им.

## <a name="denial-of-service-dos-attacks"></a>Атаки типа "отказ в обслуживании" (DoS)

Атаки типа "отказ в обслуживании" (DoS) подразумевают, что клиент выводит на сервер недоступность одного или нескольких ресурсов из-за того, что приложение не будет доступно. BlazorСерверные приложения включают некоторые ограничения по умолчанию и используют другие ASP.NET Core и SignalR ограничения для защиты от атак DOS, заданных в <xref:Microsoft.AspNetCore.Components.Server.CircuitOptions> .

| BlazorОграничение серверного приложения | Описание | Значение по умолчанию |
| --- | --- | --- |
| <xref:Microsoft.AspNetCore.Components.Server.CircuitOptions.DisconnectedCircuitMaxRetained> | Максимальное число отключенных каналов, которые заданный сервер удерживает в памяти за один раз. | 100 |
| <xref:Microsoft.AspNetCore.Components.Server.CircuitOptions.DisconnectedCircuitRetentionPeriod> | Максимальное время, в течение которого отключенная цепь удерживается в памяти, прежде чем будет прервана. | 3 минуты |
| <xref:Microsoft.AspNetCore.Components.Server.CircuitOptions.JSInteropDefaultCallTimeout> | Максимальное время ожидания сервера до истечения времени ожидания асинхронного вызова функции JavaScript. | 1 минута |
| <xref:Microsoft.AspNetCore.Components.Server.CircuitOptions.MaxBufferedUnacknowledgedRenderBatches> | Максимальное число неподтвержденных пакетов рендеринга, которые сервер хранит в памяти на канал в указанное время для поддержки надежного повторного подключения. После достижения предела сервер прекращает создавать новые пакеты рендеринга, пока один или несколько пакетов не будут подтверждены клиентом. | 10 |

Установите максимальный размер сообщения одного входящего концентратора с помощью <xref:Microsoft.AspNetCore.SignalR.HubConnectionContextOptions> .

| SignalRи ограничения ASP.NET Core | Описание | Значение по умолчанию |
| --- | --- | --- |
| <xref:Microsoft.AspNetCore.SignalR.HubConnectionContextOptions.MaximumReceiveMessageSize?displayProperty=nameWithType> | Размер сообщения для отдельного сообщения. | 32 КБ |

## <a name="interactions-with-the-browser-client"></a>Взаимодействие с браузером (клиент)

Клиент взаимодействует с сервером через JS-событие взаимодействия и завершение отрисовки. Взаимодействие между JavaScript и .NET осуществляется в обоих направлениях:

* События браузера отправляются с клиента на сервер асинхронным образом.
* Сервер отвечает асинхронно, при необходимости, перерисовывает пользовательский интерфейс.

### <a name="javascript-functions-invoked-from-net"></a>Функции JavaScript, вызываемые из .NET

Для вызовов из методов .NET к JavaScript:

* Все вызовы имеют настраиваемое время ожидания, по истечении которых они завершаются сбоем, возвращая в <xref:System.OperationCanceledException> вызывающий объект.
  * По умолчанию время ожидания вызовов ( <xref:Microsoft.AspNetCore.Components.Server.CircuitOptions.JSInteropDefaultCallTimeout?displayProperty=nameWithType> ) равно одной минуте. Чтобы настроить это ограничение, см <xref:blazor/call-javascript-from-dotnet#harden-js-interop-calls> . раздел.
  * Для управления отменой на основе каждого вызова можно предоставить токен отмены. Полагаться на время ожидания вызова по умолчанию, когда это возможно, и с ограниченным временем любым вызовом клиента, если предоставлен токен отмены.
* Результат вызова JavaScript не может быть доверенным. BlazorКлиент приложения, запущенный в браузере, выполняет поиск вызываемой функции JavaScript. Вызывается функция и создается либо результат, либо ошибка. Вредоносный клиент может попытаться:
  * Вызывает проблемы в приложении, возвращая ошибку из функции JavaScript.
  * Вызывает непреднамеренное поведение сервера, возвращая непредвиденный результат из функции JavaScript.

Примите следующие меры предосторожности, чтобы защититься от предыдущих сценариев.

* Заключите вызовы взаимодействия JS внутри операторов [try-catch](/dotnet/csharp/language-reference/keywords/try-catch) , чтобы учитывать ошибки, которые могут возникнуть во время вызовов. Для получения дополнительной информации см. <xref:blazor/handle-errors#javascript-interop>.
* Перед выполнением каких бы то ни было действий проверьте данные, возвращаемые при вызовах взаимодействия с JS, включая сообщения об ошибках.

### <a name="net-methods-invoked-from-the-browser"></a>Методы .NET, вызываемые из браузера

Не следует доверять вызовам от JavaScript к методам .NET. Когда метод .NET предоставляется JavaScript, рассмотрите способ вызова метода .NET:

* Рассматривайте любой метод .NET, предоставляемый JavaScript, так же, как общедоступная конечная точка приложения.
  * Проверьте входные данные.
    * Убедитесь, что значения находятся в пределах ожидаемых диапазонов.
    * Убедитесь, что у пользователя есть разрешение на выполнение запрошенного действия.
  * Не выделяйте чрезмерное количество ресурсов в рамках вызова метода .NET. Например, выполните проверки и ограничения на использование ЦП и памяти.
  * Примите во внимание, что статический метод и методы экземпляра могут предоставляться клиентам JavaScript. Избегайте совместного использования состояний в сеансах, если только не вызывается конструктор для предоставления общего состояния с соответствующими ограничениями.
    * Для методов экземпляров, предоставляемых через `DotNetReference` объекты, которые изначально были созданы с помощью внедрения зависимостей (DI), объекты должны быть зарегистрированы как объекты с областью действия. Это относится к любой службе DI, Blazor используемой серверным приложением.
    * Для статических методов Избегайте установки состояния, которое не может быть ограничено клиентом, если только приложение явно не предоставляет состояние по-проектированию для всех пользователей на экземпляре сервера.
  * Старайтесь не передавать пользовательские данные в параметрах вызовов JavaScript. Если передача данных в параметрах является абсолютно обязательной, убедитесь, что код JavaScript обрабатывает передачу данных без введения уязвимостей [межсайтовых сценариев (XSS)](#cross-site-scripting-xss) . Например, не записывайте данные, предоставленные пользователем, в модель DOM (DOM), задав `innerHTML` свойство элемента. Рассмотрите возможность использования [политики безопасности содержимого (CSP)](https://developer.mozilla.org/docs/Web/HTTP/CSP) для отключения `eval` и других ненадежных примитивов JavaScript.
* Избегайте реализации пользовательского диспетчеризации вызовов .NET поверх реализации диспетчеризации платформы. Предоставление доступа к методам .NET для браузера является расширенным сценарием, не рекомендуемым для общей Blazor разработки.

### <a name="events"></a>События

События предоставляют точку входа для Blazor серверного приложения. Те же правила защиты конечных точек в веб-приложениях применяются к обработке событий в Blazor серверных приложениях. Вредоносный клиент может отправить в качестве полезных данных для события любые данные, которые он хочет отправить.

Пример.

* Событие изменения для `<select>` может отправить значение, не находящиеся в параметрах, представленных приложением для клиента.
* `<input>`Может отправить на сервер любые текстовые данные, минуя проверку на стороне клиента.

Приложение должно проверить данные для любого события, обрабатываемого приложением. Blazor [Компоненты форм](xref:blazor/forms-validation) платформы выполняют основные проверки. Если приложение использует пользовательские компоненты форм, для проверки правильности данных событий необходимо написать пользовательский код.

BlazorСобытия сервера являются асинхронными, поэтому на сервере можно отправить несколько событий, прежде чем приложение сможет реагировать на них, создавая новый рендеринг. Это позволяет учитывать некоторые аспекты безопасности. Ограничение клиентских действий в приложении должно выполняться внутри обработчиков событий и не зависеть от текущего состояния представления, готового к просмотру.

Рассмотрим компонент счетчика, который должен позволить пользователю увеличить счетчик до трех раз. Кнопка для увеличения счетчика зависит от значения `count` :

```razor
<p>Count: @count<p>

@if (count < 3)
{
    <button @onclick="IncrementCount" value="Increment count" />
}

@code 
{
    private int count = 0;

    private void IncrementCount()
    {
        count++;
    }
}
```

Клиент может отправить одно или несколько событий приращения, прежде чем платформа создаст новый рендеринг этого компонента. Результат заключается в том, что `count` пользователь может увеличиваться в *три раза* , поскольку кнопка не УДАЛЯЕТСЯ в пользовательском интерфейсе достаточно быстро. Правильный способ достижения ограничения в три `count` шага показан в следующем примере:

```razor
<p>Count: @count<p>

@if (count < 3)
{
    <button @onclick="IncrementCount" value="Increment count" />
}

@code 
{
    private int count = 0;

    private void IncrementCount()
    {
        if (count < 3)
        {
            count++;
        }
    }
}
```

Если добавить `if (count < 3) { ... }` проверку внутри обработчика, решение приращения `count` будет основано на текущем состоянии приложения. Решение не зависит от состояния пользовательского интерфейса, которое было в предыдущем примере, что может быть временно устаревшим.

### <a name="guard-against-multiple-dispatches"></a>Защита от нескольких отправок

Если обратный вызов события асинхронно вызывает длительную операцию, например получение данных из внешней службы или базы данных, рассмотрите возможность использования защиты. Это условие может препятствовать постановке пользователем в очередь нескольких операций во время выполнения операции с визуальным отзывом. Следующий код компонента задает `isLoading` значение, чтобы `true` при `GetForecastAsync` получении данных с сервера. Пока `isLoading` имеет значение `true` , кнопка отключена в пользовательском интерфейсе:

```razor
@page "/fetchdata"
@using BlazorServerSample.Data
@inject WeatherForecastService ForecastService

<button disabled="@isLoading" @onclick="UpdateForecasts">Update</button>

@code {
    private bool isLoading;
    private WeatherForecast[] forecasts;

    private async Task UpdateForecasts()
    {
        if (!isLoading)
        {
            isLoading = true;
            forecasts = await ForecastService.GetForecastAsync(DateTime.Now);
            isLoading = false;
        }
    }
}
```

Шаблон защиты, показанный в предыдущем примере, работает, если фоновая операция выполняется асинхронно с использованием `async` - `await` шаблона.

### <a name="cancel-early-and-avoid-use-after-dispose"></a>Отмена в начале и избежание использования-After-Dispose

Помимо использования защиты, как описано в разделе [Защита от нескольких исправлений](#guard-against-multiple-dispatches) , рекомендуется использовать <xref:System.Threading.CancellationToken> для отмены длительных операций при удалении компонента. Этот подход обладает дополнительными преимуществами для предотвращения *использования после удаления* в компонентах:

```razor
@implements IDisposable

...

@code {
    private readonly CancellationTokenSource TokenSource = 
        new CancellationTokenSource();

    private async Task UpdateForecasts()
    {
        ...

        forecasts = await ForecastService.GetForecastAsync(DateTime.Now, 
            TokenSource.Token);

        if (TokenSource.Token.IsCancellationRequested)
        {
           return;
        }

        ...
    }

    public void Dispose()
    {
        TokenSource.Cancel();
    }
}
```

### <a name="avoid-events-that-produce-large-amounts-of-data"></a>Избегайте событий, создающих большие объемы данных

Некоторые события DOM, такие как `oninput` или `onscroll` , могут создавать большой объем данных. Избегайте использования этих событий в Blazor серверных приложениях.

## <a name="additional-security-guidance"></a>Дополнительные рекомендации по безопасности

Рекомендации по защите ASP.NET Core приложений применяются к Blazor серверным приложениям и рассматриваются в следующих разделах:

* [Ведение журнала и конфиденциальные данные](#logging-and-sensitive-data)
* [Защита информации при передаче с помощью HTTPS](#protect-information-in-transit-with-https)
* [Межсайтовые сценарии (XSS)](#cross-site-scripting-xss)
* [Защита от разных источников](#cross-origin-protection)
* [Щелчок](#click-jacking)
* [Открыть перенаправления](#open-redirects)

### <a name="logging-and-sensitive-data"></a>Ведение журнала и конфиденциальные данные

Взаимодействие взаимодействия между клиентом и сервером осуществляется в журналы сервера с <xref:Microsoft.Extensions.Logging.ILogger> экземплярами. Blazorпредотвращает ведение журнала конфиденциальной информации, например фактических событий или входных и выходных данных взаимодействия JS.

При возникновении ошибки на сервере платформа уведомляет клиента и слезами сеанс. По умолчанию клиент получает общее сообщение об ошибке, которое можно увидеть в средствах разработчика браузера.

Ошибка на стороне клиента не включает стек вызовов и не предоставляет сведений о причине ошибки, но журналы сервера содержат такие сведения. В целях разработки конфиденциальные сведения об ошибках можно сделать доступными для клиента, включив подробные ошибки.

Включить подробные сведения об ошибках в JavaScript с помощью:

* <xref:Microsoft.AspNetCore.Components.Server.CircuitOptions.DetailedErrors?displayProperty=nameWithType>.
* `DetailedErrors`Для ключа конфигурации задано значение `true` , которое можно задать в файле параметров приложения (*appSettings. JSON*). Ключ также можно задать с помощью `ASPNETCORE_DETAILEDERRORS` переменной среды со значением `true` .

> [!WARNING]
> Предоставление сведений об ошибках клиентам в Интернете является угрозой безопасности, которую всегда следует избегать.

### <a name="protect-information-in-transit-with-https"></a>Защита информации при передаче с помощью HTTPS

BlazorСервер использует SignalR для обмена данными между клиентом и сервером. BlazorСервер обычно использует транспорт, который SignalR согласовывает (обычно это WebSockets).

BlazorСервер не гарантирует целостность и конфиденциальность данных, передаваемых между сервером и клиентом. Всегда используйте HTTPS.

### <a name="cross-site-scripting-xss"></a>Межсайтовые сценарии (XSS)

Межсайтовые сценарии (XSS) позволяют неавторизованной стороне выполнять произвольную логику в контексте браузера. Скомпрометированное приложение потенциально может выполнять произвольный код на клиенте. Уязвимость может быть использована для выполнения ряда вредоносных действий на сервере.

* Отправка фиктивных или недопустимых событий на сервер.
* Отработка отказа/недопустимые завершения подготовки к просмотру.
* Избегайте диспетчеризации завершений рендеринга.
* Отправка вызовов взаимодействия из JavaScript в .NET.
* Измените ответ вызовов взаимодействия с .NET на JavaScript.
* Избегайте отправки результатов взаимодействия .NET с JS.

BlazorСерверная платформа предпринимает меры для защиты от некоторых из предыдущих угроз.

* Прекращает создание новых обновлений пользовательского интерфейса, если клиент не будет подтверждать пакеты отрисовки. Настроено с помощью <xref:Microsoft.AspNetCore.Components.Server.CircuitOptions.MaxBufferedUnacknowledgedRenderBatches?displayProperty=nameWithType> .
* Истечение времени ожидания вызова .NET to JavaScript через одну минуту без получения ответа от клиента. Настроено с помощью <xref:Microsoft.AspNetCore.Components.Server.CircuitOptions.JSInteropDefaultCallTimeout?displayProperty=nameWithType> .
* Выполняет базовую проверку всех входных данных, поступающих из браузера во время взаимодействия с JS:
  * Ссылки на .NET являются допустимыми и типа, ожидаемого методом .NET.
  * Данные не имеют неправильный формат.
  * В полезных данных содержится правильное число аргументов для метода.
  * Аргументы или результат можно правильно десериализовать перед вызовом метода.
* Выполняет базовую проверку всех входных данных, поступающих от браузера, от отправленных событий:
  * Событие имеет допустимый тип.
  * Данные для события могут быть десериализованы.
  * С событием связан обработчик событий.

В дополнение к средствам защиты, реализуемым платформой, приложение должно быть закодировано разработчиком для защиты от угроз и выполнения соответствующих действий:

* Всегда проверяйте данные при обработке событий.
* Предпринимать необходимые действия при получении недопустимых данных:
  * Пропускать данные и возвращать. Это позволяет приложению продолжить обработку запросов.
  * Если приложение определяет, что входные данные столкновении и не могут быть получены законным клиентом, вызовите исключение. Создание исключения слезами канал вниз и завершает сеанс.
* Не следует доверять сообщению об ошибке, предоставленному в журналах завершения обработки пакетов, включенных в журналы. Эта ошибка предоставляется клиентом и не может быть доверенной, так как клиент может быть скомпрометирован.
* Не следует доверять входным вызовам взаимодействия на JS в любом направлении между методами JavaScript и .NET.
* Приложение отвечает за проверку допустимости содержимого аргументов и результатов, даже если аргументы или результаты правильно десериализованы.

Чтобы уязвимость XSS существовала, приложение должно включить пользовательский ввод на странице, подготовленной для просмотра. BlazorСерверные компоненты выполняют шаг времени компиляции, при котором разметка в файле *Razor* преобразуется в процедурную логику C#. Во время выполнения логика C# создает *дерево отрисовки* , описывающее элементы, текст и дочерние компоненты. Это применяется к DOM браузера через последовательность инструкций JavaScript (или сериализуется в HTML в случае предварительной визуализации):

* Пользовательский ввод, отображаемый с помощью обычного Razor синтаксиса (например, `@someStringValue` ), не предоставляет уязвимость XSS, так как Razor синтаксис ДОБАВЛЯЕТся в DOM с помощью команд, которые могут записывать только текст. Даже если значение включает HTML-разметку, значение отображается как статический текст. При предварительной отрисовке выходные данные кодируются в формате HTML, что также отображает содержимое в виде статического текста.
* Теги скриптов не допускаются и не должны включаться в дерево визуализации компонента приложения. Если тег скрипта включен в разметку компонента, создается ошибка времени компиляции.
* Авторы компонентов могут создавать компоненты на языке C# без использования Razor . Автор компонента несет ответственность за использование правильных API-интерфейсов при выдаче выходных данных. Например, используйте, `builder.AddContent(0, someUserSuppliedString)` а *не* `builder.AddMarkupContent(0, someUserSuppliedString)` , так как в последнем случае может быть создана уязвимость XSS.

В рамках защиты от атак XSS рассмотрите возможность реализации предотвращения взлома XSS, например [политики безопасности содержимого (CSP)](https://developer.mozilla.org/docs/Web/HTTP/CSP).

Для получения дополнительной информации см. <xref:security/cross-site-scripting>.

### <a name="cross-origin-protection"></a>Защита от разных источников

Атаки между источниками предполагают, что клиент из другого источника выполняет действие с сервером. Вредоносным действием обычно является запрос GET или форма POST (подделка межсайтовых запросов, CSRF), но также возможен открытие вредоносного WebSocket. BlazorСерверные приложения предлагают [те же гарантии, что и любое другое SignalR приложение, использующее предложение по протоколу концентратора](xref:signalr/security):

* BlazorДоступ к серверным приложениям можно получить из нескольких источников, если не будут предприняты дополнительные меры для их предотвращения. Чтобы отключить доступ между источниками, отключите CORS в конечной точке, добавив по промежуточного слоя CORS в конвейер и добавив в <xref:Microsoft.AspNetCore.Cors.DisableCorsAttribute> Blazor метаданные конечной точки или ограничив набор разрешенных источников, [настроив SignalR для общего доступа к ресурсам между источниками](xref:signalr/security#cross-origin-resource-sharing).
* Если CORS включен, для защиты приложения могут потребоваться дополнительные действия в зависимости от конфигурации CORS. Если CORS глобально включена, CORS можно отключить для Blazor концентратора сервера, добавив <xref:Microsoft.AspNetCore.Cors.DisableCorsAttribute> метаданные в метаданные конечной точки после вызова <xref:Microsoft.AspNetCore.Builder.ComponentEndpointRouteBuilderExtensions.MapBlazorHub%2A> в построителе маршрутов конечной точки.

Для получения дополнительной информации см. <xref:security/anti-request-forgery>.

### <a name="click-jacking"></a>Щелчок

При нажатии кнопки «гнездо» выполняется подготовка сайта к просмотру `<iframe>` внутри сайта с другого источника, чтобы заставить пользователя выполнять действия на веб-узле при атаке.

Чтобы защитить приложение от подготовки к просмотру в `<iframe>` , используйте [политику безопасности содержимого (CSP)](https://developer.mozilla.org/docs/Web/HTTP/CSP) и `X-Frame-Options` заголовок. Дополнительные сведения см. в разделе [MDN Web документация: X-Frame-Options](https://developer.mozilla.org/docs/Web/HTTP/Headers/X-Frame-Options).

### <a name="open-redirects"></a>Открыть перенаправления

При Blazor запуске сеанса серверного приложения сервер выполняет базовую проверку URL-адресов, отправляемых в процессе запуска сеанса. Платформа проверяет, является ли базовый URL-адрес родительским по отношению к текущему URL-адресу, прежде чем устанавливать канал. Платформа не выполняет никаких дополнительных проверок.

Когда пользователь выбирает ссылку на клиенте, URL-адрес ссылки отправляется на сервер, который определяет, какое действие следует предпринять. Например, приложение может выполнить навигацию на стороне клиента или указать браузеру, чтобы перейти к новому расположению.

Компоненты также могут запускать запросы навигации программно с помощью <xref:Microsoft.AspNetCore.Components.NavigationManager> . В таких случаях приложение может выполнить навигацию на стороне клиента или указать браузеру, чтобы перейти к новому расположению.

Компоненты должны:

* Старайтесь не использовать входные данные пользователя как часть аргументов вызова навигации.
* Проверьте аргументы, чтобы убедиться, что целевой объект разрешен приложением.

В противном случае злонамеренный пользователь может заставить браузер попасть на управляемый злоумышленником сайт. В этом случае злоумышленник применяет приложение к использованию некоторых входных данных, вводимых пользователем, в ходе вызова <xref:Microsoft.AspNetCore.Components.NavigationManager.NavigateTo%2A?displayProperty=nameWithType> метода.

Этот Совет также применяется при подготовке к просмотру ссылок в составе приложения:

* По возможности используйте относительные ссылки.
* Убедитесь, что ссылки на абсолютные адреса являются допустимыми, прежде чем включать их в страницу.

Для получения дополнительной информации см. <xref:security/preventing-open-redirects>.

## <a name="security-checklist"></a>Контрольный список по безопасности

Следующий список вопросов безопасности не является исчерпывающим:

* Проверка аргументов из событий.
* Проверка входных данных и результатов вызовов взаимодействия JS.
* Старайтесь не использовать (или проверять заранее) пользовательский ввод для вызовов взаимодействия .NET to JS.
* Запретить клиенту выделение непривязанного объема памяти.
  * Данные в компоненте.
  * `DotNetObject`ссылки, возвращаемые клиенту.
* Защита от нескольких диспетчеризации.
* Отмена длительных операций при удалении компонента.
* Избегайте событий, создающих большие объемы данных.
* Избегайте использования вводимых пользователем данных в рамках вызовов <xref:Microsoft.AspNetCore.Components.NavigationManager.NavigateTo%2A?displayProperty=nameWithType> и проверки вводимых пользователем данных для URL-адресов с набором разрешенных источников сначала, если это не так.
* Не следует принимать решения об авторизации на основе состояния пользовательского интерфейса, но только из состояния компонента.
* Рассмотрите возможность использования [политики безопасности содержимого (CSP)](https://developer.mozilla.org/docs/Web/HTTP/CSP) для защиты от атак XSS.
* Используйте CSP и [X-Frame-параметры](https://developer.mozilla.org/docs/Web/HTTP/Headers/X-Frame-Options) для защиты от щелчков.
* Убедитесь, что параметры CORS подходят при включении CORS или явном отключении CORS для Blazor приложений.
* Проверьте, что ограничения на стороне сервера для Blazor приложения обеспечивают приемлемое взаимодействие с пользователем без неприемлемых уровней риска.
